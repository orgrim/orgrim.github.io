<!DOCTYPE html>


<html lang="fr" data-theme="">
<head>
    
        
<meta charset="utf-8">
<meta name="HandheldFriendly" content="True">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer-when-downgrade">

<title>PostgreSQL et SELinux à l&#39;ère de systemd - code. grind. sleep.</title>
<meta name="description" content="">

<link rel="icon" type="image/x-icon" href="https://www.orgrim.net/favicon.ico">
<link rel="apple-touch-icon-precomposed" href="https://www.orgrim.net/favicon.png">



    





    
    
    

    
        <link rel="stylesheet" href="https://www.orgrim.net/css/style.6155b6d8eded05b985178f56a637943b3e7fcfccc913d9c656bbebce7c91cc6b.css" integrity="sha256-YVW22O3tBbmFF49WpjeUOz5/z8zJE9nGVrvrznyRzGs=">
    





    





    
        <link rel="stylesheet" href="https://www.orgrim.net/css/custom.css?rnd=1613063810">
    


    





    
        <link rel="stylesheet" href="https://www.orgrim.net/css/syntax.css?rnd=1613063810">
    




<meta property="og:title" content="PostgreSQL et SELinux à l&#39;ère de systemd" />
<meta property="og:description" content="Ce post se veut une mise à jour du post précédent sur le sujet. En
effet, le module SELinux, les commandes utilisées ont évolué avec
l&rsquo;adoption de systemd. Les principes restent les mêmes." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.orgrim.net/post/2021-02-11-postgresql-et-selinux/" />
<meta property="article:published_time" content="2021-02-11T10:00:00+01:00" />
<meta property="article:modified_time" content="2021-02-11T10:00:00+01:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="PostgreSQL et SELinux à l&#39;ère de systemd"/>
<meta name="twitter:description" content="Ce post se veut une mise à jour du post précédent sur le sujet. En
effet, le module SELinux, les commandes utilisées ont évolué avec
l&rsquo;adoption de systemd. Les principes restent les mêmes."/>









    
</head>
<body>
    <a class="skip-main" href="#main">Aller au contenu</a>
    <div class="container">
        <header class="common-header"> 
            
                <h1 class="site-title">
    <a href="/">code. grind. sleep.</a>
</h1>

    <nav>
        
        
        <a class="" href="https://www.orgrim.net/post" title="">Blog</a>
        
        <a class="" href="https://www.orgrim.net/categories" title="">Categories</a>
        
        <a class="" href="https://www.orgrim.net/tags" title="">Tags</a>
        
    </nav>


            
        </header>
        <main id="main" tabindex="-1"> 
            
    
    
    <article class="post">
        <header class="post-header">
            <h1 class="post-title">PostgreSQL et SELinux à l&#39;ère de systemd</h1>
        </header>
        <div class="content">
            <p>Ce post se veut une mise à jour du <a href="/post/2014-09-22-confiner-postgresql-avec-selinux/">post précédent</a> sur le sujet. En
effet, le module SELinux, les commandes utilisées ont évolué avec
l&rsquo;adoption de systemd. Les principes restent les mêmes.</p>
<p>Pour confiner une instance PostgreSQL avec SELinux, il faut configurer
plusieurs éléments :</p>
<ul>
<li>
<p>Les « file contexts » : les binaires et les données doivent avoir le
bon type dans la famille des contexts PostgreSQL. Cela se fait avec
des regexp et la commande <code>semanage fcontext</code> en local ou par un
module SELinux.</p>
<p>Par exemple pour créer une instance dans <code>/srv/pgsql</code> :</p>
<pre><code class="language-console" data-lang="console"># semanage fcontext -a -t postgresql_db_t /srv/pgsql(/.*)?
</code></pre><p>On ajoutera des règles similaires pour les tablespaces.</p>
</li>
<li>
<p>le port TCP : dans la politique par défaut du système le port 5432
est bien taggué, pour faire écouter PostgreSQL sur un autre port, il
ne doit pas être taggué avec un autre type SElinux et explicitement
taggué avec le type <code>postgresql_port_t</code> avec la commande <code>semanage port</code>.</p>
<p>Par exemple pour faire écouter l&rsquo;instance sur le port 5433 :</p>
<pre><code class="language-console" data-lang="console"># semanage port -a -p tcp -t postgresql_port_t 5433
</code></pre></li>
<li>
<p>activer des « boolean » SELinux : par exemple pour autoriser
l&rsquo;utilisation de <code>rsync</code> par un processus PostgreSQL confiné, utile
pour l&rsquo;archivage des WAL.</p>
<p>Par exemple :</p>
<pre><code class="language-console" data-lang="console"># semanage boolean -m --on postgresql_can_rsync
</code></pre></li>
</ul>
<p>Le module <code>postgresql-pgdg</code> disponible ici :
<a href="https://github.com/dalibo/selinux-pgsql-pgdg">https://github.com/dalibo/selinux-pgsql-pgdg</a> fournit des file
contexts et boolean pour cela.</p>
<p>Ensuite, il y a deux moyens pour confiner <em>vraiment</em> l&rsquo;instance :</p>
<ul>
<li>Lancer le postmaster avec systemd</li>
<li>Lancer <code>pg_ctl</code> avec <code>runcon</code></li>
</ul>
<p>Avec systemd, c&rsquo;est automatique, mais il faut être root ou avoir
l&rsquo;autorisation de le faire avec sudo.</p>
<p>Avec <code>pg_ctl</code>, c&rsquo;est un peu plus délicat. Avec la politique par
défaut, on a le plus souvent un shell de l&rsquo;utilisateur <code>postgres</code> non
confiné, donc avec l&rsquo;user SELinux <code>unconfiend_u</code>. Cet user SELinux a
les roles <code>system_r</code> et <code>unconfined_r</code>, il peut donc exécuter des
process avec le role <code>system_r</code> (voir la sortie <code>semanage user -l</code>). Cela permet d&rsquo;utiliser <code>runcon</code> pour exécuter <code>pg_ctl</code> dans le
même context que celui utilisé par systemd pour confiner PostgreSQL :</p>
<pre><code class="language-console" data-lang="console">$ runcon system_u:system_r:postgresql_t:s0 pg_ctl -D /srv/pgsql/12/main start
$ ps xfZ
LABEL                             PID TTY      STAT   TIME COMMAND
unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 1317 pts/0 S   0:00 -bash
unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 1334 pts/0 R+   0:00  \_ ps xfZ
system_u:system_r:postgresql_t:s0 1144 ?       Ss     0:00 /usr/pgsql-12/bin/postgres -D /srv/pgsql/12/main
system_u:system_r:postgresql_t:s0 1176 ?       Ss     0:00  \_ postgres: main: logger
system_u:system_r:postgresql_t:s0 1178 ?       Ss     0:00  \_ postgres: main: checkpointer
system_u:system_r:postgresql_t:s0 1179 ?       Ss     0:00  \_ postgres: main: background writer
system_u:system_r:postgresql_t:s0 1180 ?       Ss     0:00  \_ postgres: main: walwriter
system_u:system_r:postgresql_t:s0 1181 ?       Ss     0:00  \_ postgres: main: autovacuum launcher
system_u:system_r:postgresql_t:s0 1182 ?       Ss     0:00  \_ postgres: main: archiver   last was 00000001000000000
system_u:system_r:postgresql_t:s0 1183 ?       Ss     0:00  \_ postgres: main: stats collector
system_u:system_r:postgresql_t:s0 1184 ?       Ss     0:00  \_ postgres: main: logical replication launcher
</code></pre><p>Enfin, la sauvegarde, du fait que l&rsquo;archivage soit exécuté par
l&rsquo;instance, est impactée par SELinux. En plus des droits unix
classiques, le context <code>postgresql_t</code> doit pouvoir écrire dans le
répertoire d&rsquo;archivage s&rsquo;il est local. Il faut donc que ce répertoire
ait le contexte <code>postgresql_db_t</code>. Ce n&rsquo;est pas forcément suffisant si
le répertoire de stockage des WAL archivés est dans un point de
montage réseau. Il existe pour cela les booléens :</p>
<ul>
<li><code>postgresql_pgdg_use_nfs</code> pour les montages NFS</li>
<li><code>postgresql_pgdg_use_fusefs</code> pour les montages plus exotiques utilisant FUSE</li>
</ul>
<p>Le paquet RPM pour RHEL/CentOS est disponible dans le dépot
<a href="https://yum.dalibo.org/labs/">https://yum.dalibo.org/labs/</a>, sous le nom
<code>selinux-policy-pgsql-pgdg</code>.</p>
        </div>
        

    


<div class="post-info">
    
        <div class="post-date">2021-02-11</div>
    
    <div class="post-taxonomies">
        
            <ul class="post-categories">
                
                    <li><a href="https://www.orgrim.net/categories/">PostgreSQL</a></li>
                
            </ul>
            
            
                <ul class="post-tags">
                    
                        <li><a href="https://www.orgrim.net/tags/postgresql">#postgresql</a></li>
                    
                        <li><a href="https://www.orgrim.net/tags/selinux">#selinux</a></li>
                    
                </ul>
        
    </div>
</div>

    </article>

    

    


        </main>
        
            <footer class="common-footer">
    
    
        <ul class="language-select">

<li><a href="https://www.orgrim.net/">Français</a></li>

<li><a href="https://www.orgrim.net/en/">English</a></li>

</ul>
    

    <div class="common-footer-bottom">
        
            
            <ul class="footer-menu">
            
            <li><a class="" href="https://twitter.com/orgrim" title="Twitter">@orgrim</a></li>
            
            <li><a class="" href="https://github.com/orgrim" title="">github</a></li>
            
            </ul>
        
        <div class="copyright">
            <p>© Nicolas Thauvin, 2021<br>
            Propulsé par <a target="_blank" rel="noopener noreferrer" href="https://gohugo.io/">Hugo</a>, thème <a target="_blank" rel="noopener noreferrer" href="https://github.com/mitrichius/hugo-theme-anubis">Anubis</a>.
            </p>  
        </div> 

        

    



    <button class="theme-switcher">
        Thème sombre
    </button>

    <script>
    const STORAGE_KEY = 'user-color-scheme'
    const defaultTheme = "dark"

    let currentTheme
    let switchButton
    let autoDefinedScheme = window.matchMedia('(prefers-color-scheme: dark)')

    const autoChangeScheme = e => {
        currentTheme = e.matches ? 'dark' : 'light'
        document.documentElement.setAttribute('data-theme', currentTheme)
        changeButtonText()
    }

    document.addEventListener('DOMContentLoaded', function() {
        switchButton = document.querySelector('.theme-switcher')
        currentTheme = detectCurrentScheme()
        if (currentTheme == 'dark') {
            document.documentElement.setAttribute('data-theme', 'dark')
        }
        if (currentTheme == 'auto') {
            autoChangeScheme(autoDefinedScheme);
            autoDefinedScheme.addListener(autoChangeScheme);
        }
        changeButtonText()
        switchButton.addEventListener('click', switchTheme, false)
    })

    function detectCurrentScheme() {
        if (localStorage.getItem(STORAGE_KEY)) {
            return localStorage.getItem(STORAGE_KEY)
        } 
        if (defaultTheme) {
            return defaultTheme
        } 
        if (!window.matchMedia) {
            return 'light'
        } 
        if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
            return 'dark'
        }
        return 'light'
    }

    function changeButtonText()
    {   
        switchButton.textContent = currentTheme == 'dark' ?  "Thème clair" : "Thème sombre"
    }

    function switchTheme(e) {
        if (currentTheme == 'dark') {
            localStorage.setItem(STORAGE_KEY, 'light')
            document.documentElement.setAttribute('data-theme', 'light')
            currentTheme = 'light'
        } else {
            localStorage.setItem(STORAGE_KEY, 'dark')
            document.documentElement.setAttribute('data-theme', 'dark')
            currentTheme = 'dark'
        }
        changeButtonText()
    }
    </script>
   
    </div>
</footer>

        
    </div>
</body>
</html>
