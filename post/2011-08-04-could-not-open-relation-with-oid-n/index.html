<!DOCTYPE html>


<html lang="fr" data-theme="">
<head>
    
        
<meta charset="utf-8">
<meta name="HandheldFriendly" content="True">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer-when-downgrade">

<title>Could not open relation with oid N - code. grind. sleep.</title>
<meta name="description" content="">

<link rel="icon" type="image/x-icon" href="https://www.orgrim.net/favicon.ico">
<link rel="apple-touch-icon-precomposed" href="https://www.orgrim.net/favicon.png">

<link rel="stylesheet" href="https://www.orgrim.net/css/light.css?rnd=1605390221" />
<style>

    [data-theme="dark"] {   
        --font-color: #eee;
--bg-color: #212121;

--link-color:#599ada;
--link-state-color:#ff5858;
--link-state-border-color: rgba(238, 54, 54, 0.5);

--thead-bg-color: #343a40;
--table-border-color: lightgrey;

--pre-color: #333;
--pre-bg-color: #f1f1f1;

--bq-color: #ccc;
--hr-color: #333;

--pagination-bg-color: #373737;
--pagination-link-color: #b6b6b6;

--post-info-color: grey;

--switcher-color: #333;
--switcher-bg-color: #fff;

    }

</style>

<link rel="stylesheet" href="https://www.orgrim.net/css/style.css?rnd=1605390221" />

<link rel="stylesheet" href="https://www.orgrim.net/css/custom.css?rnd=1605390221"><link rel="stylesheet" href="https://www.orgrim.net/css/syntax.css?rnd=1605390221">



<meta property="og:title" content="Could not open relation with oid N" />
<meta property="og:description" content="On peut parfois trouver cet étrange message d&rsquo;erreur dans les traces de PostgreSQL (N étant un nombre) ou lors de l&rsquo;exécution d&rsquo;une requête :
ERROR: could not open relation with OID N  Si on recherche ce message dans les mailing-lists du projet, on peut facilement conclure que la base de données est corrompue, qu&rsquo;il y a des problèmes matériels et que la sécurité des données est en péril. Et bien, ce n&rsquo;est pas forcément le cas : obtenir ce message peut être tout à fait normal." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.orgrim.net/post/2011-08-04-could-not-open-relation-with-oid-n/" />
<meta property="article:published_time" content="2011-08-04T00:00:00+00:00" />
<meta property="article:modified_time" content="2011-08-04T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Could not open relation with oid N"/>
<meta name="twitter:description" content="On peut parfois trouver cet étrange message d&rsquo;erreur dans les traces de PostgreSQL (N étant un nombre) ou lors de l&rsquo;exécution d&rsquo;une requête :
ERROR: could not open relation with OID N  Si on recherche ce message dans les mailing-lists du projet, on peut facilement conclure que la base de données est corrompue, qu&rsquo;il y a des problèmes matériels et que la sécurité des données est en péril. Et bien, ce n&rsquo;est pas forcément le cas : obtenir ce message peut être tout à fait normal."/>








    
</head>
<body>
    <a class="skip-main" href="#main">Passer au contenu principal</a>
    <div class="container">
        <header class="common-header"> 
            
                <h1 class="site-title">
    <a href="/">code. grind. sleep.</a>
</h1>

    <nav>
        
        
        <a class="" href="https://www.orgrim.net/" title="">Blog</a>
        
        <a class="" href="https://www.orgrim.net/categories" title="">Categories</a>
        
        <a class="" href="https://www.orgrim.net/tags" title="">Tags</a>
        
    </nav>


            
        </header>
        <main id="main" tabindex="-1"> 
            
    
    
    <article class="post">
        <header class="post-header">
            <h1 class="post-title">Could not open relation with oid N</h1>
        </header>
        <div class="content">
            <p>On peut parfois trouver cet étrange message d&rsquo;erreur dans les traces de
PostgreSQL (N étant un nombre) ou lors de l&rsquo;exécution d&rsquo;une requête :</p>
<pre><code>ERROR:  could not open relation with OID N
</code></pre>
<p>Si on recherche ce message dans les mailing-lists du projet, on peut
facilement conclure que la base de données est corrompue, qu&rsquo;il y a des
problèmes matériels et que la sécurité des données est en péril. Et
bien, ce n&rsquo;est pas forcément le cas : obtenir ce message peut être tout
à fait normal.</p>
<p>Pour démontrer cela, on a besoin d&rsquo;une table :</p>
<pre><code>$ createdb test
$ psql test
psql (9.0.4)
Type &quot;help&quot; for help.

test=# CREATE TABLE truc AS SELECT generate_series(0, 5) AS i;
SELECT 6
test=#
</code></pre>
<p>On lance une session qui bloquerait un <code>DROP</code> de cette table, pour cela
on pose un verrou exclusif, le mode « ExclusiveLock » ne laisse passer
que les lectures (c&rsquo;est important pour la suite) :</p>
<pre><code>$ psql test
psql (9.0.4)
Type &quot;help&quot; for help.

test=# BEGIN;
BEGIN
test=# LOCK TABLE truc IN EXCLUSIVE MODE;
LOCK TABLE
test=#
</code></pre>
<p>On laisse cette transaction « ouverte », avec le verrou posé et on lance
une session pour supprimer la table :</p>
<pre><code>$ psql test
psql (9.0.4)
Type &quot;help&quot; for help.

test=# BEGIN;
BEGIN
test=# DROP TABLE truc;
</code></pre>
<p>L&rsquo;ordre SQL <code>DROP TABLE</code> ne rend pas la main, cette deuxième session
attend le verrou « AccessExclusiveLock », qui est le plus restrictif,
sur la table pour pouvoir la supprimer. La page
<a href="http://wiki.postgresql.org/wiki/Lock_dependency_information">http://wiki.postgresql.org/wiki/Lock_dependency_information</a> fournie une requête montrant
les dépendances entre requêtes du point de vue du verrouillage. Dans ce
cas, elle donne le résultat suivant :</p>
<pre><code> waiting_locktype | waiting_table |  waiting_query   |    waiting_mode     | waiting_pid | other_locktype | other_table |      other_query      |  other_mode   | other_pid | other_granted 
------------------+---------------+------------------+---------------------+-------------+----------------+-------------+-----------------------+---------------+-----------+---------------
 relation         | truc          | DROP TABLE truc; | AccessExclusiveLock |       25632 | relation       | truc        | &lt;IDLE&gt; in transaction | ExclusiveLock |     24217 | t
</code></pre>
<p>On lance une troisième session, avec un <code>SELECT</code> sur notre table :</p>
<pre><code>$ psql test
psql (9.0.4)
Type &quot;help&quot; for help.

test=# SELECT * FROM truc;
</code></pre>
<p>L&rsquo;ordre <code>SELECT</code> ne rend pas la main, cette troisième session se met à
attendre le <code>DROP TABLE</code> et la première session. C&rsquo;est d&rsquo;ailleurs le
<code>DROP TABLE</code> qui bloque réellement le <code>SELECT</code>, car la première session
à verrouillé la table en lecture seule :</p>
<pre><code> waiting_locktype | waiting_table |    waiting_query    |    waiting_mode     | waiting_pid | other_locktype | other_table |      other_query      |     other_mode      | other_pid | other_granted 
------------------+---------------+---------------------+---------------------+-------------+----------------+-------------+-----------------------+---------------------+-----------+---------------
 relation         | truc          | SELECT * FROM truc; | AccessShareLock     |       28629 | relation       | truc        | DROP TABLE truc;      | AccessExclusiveLock |     25632 | f
 relation         | truc          | DROP TABLE truc;    | AccessExclusiveLock |       25632 | relation       | truc        | &lt;IDLE&gt; in transaction | ExclusiveLock       |     24217 | t
 relation         | truc          | SELECT * FROM truc; | AccessShareLock     |       28629 | relation       | truc        | &lt;IDLE&gt; in transaction | ExclusiveLock       |     24217 | t
 relation         | truc          | DROP TABLE truc;    | AccessExclusiveLock |       25632 | relation       | truc        | SELECT * FROM truc;   | AccessShareLock     |     28629 | f
(4 rows)
</code></pre>
<p>On libère la première session :</p>
<pre><code>test=# ROLLBACK;
ROLLBACK
test=#
</code></pre>
<p>Le <code>DROP TABLE</code> passe, et le <code>SELECT</code> continue d&rsquo;attendre :</p>
<pre><code> waiting_locktype | waiting_table |    waiting_query    |  waiting_mode   | waiting_pid | other_locktype | other_table |      other_query      |     other_mode      | other_pid | other_granted 
------------------+---------------+---------------------+-----------------+-------------+----------------+-------------+-----------------------+---------------------+-----------+---------------
 relation         | truc          | SELECT * FROM truc; | AccessShareLock |       28629 | relation       | truc        | &lt;IDLE&gt; in transaction | AccessExclusiveLock |     25632 | t
</code></pre>
<p>On voit que le <code>SELECT</code> attend la transaction qui a lancé le
<code>DROP TABLE</code>. Même si le <code>DROP TABLE</code> est terminé, son effet ne sera
connu des transactions concurrentes seulement ou moment du commit ou
rollback, parce qu&rsquo;on utilise le niveau d&rsquo;isolation des transaction
« read committed » (par défaut). Il n&rsquo;y a pas de « <code>UNLOCK</code> » sur les
tables dans PostgreSQL, il faut attendre la fin de la transaction pour
que les verrous soient libérés, du moins lorsqu&rsquo;on n&rsquo;utilise pas de
savepoints.</p>
<p>Maintenant, on valide le <code>DROP TABLE</code>, avec l&rsquo;ordre <code>COMMIT</code>. Le
<code>SELECT</code> termine en erreur, on voit alors le message dans les logs :</p>
<pre><code>ERROR:  could not open relation with OID 17366 at character 15
STATEMENT:  SELECT * FROM truc;
</code></pre>
<p>Lorsque le <code>SELECT</code> n&rsquo;est plus bloqué par le verrou, il ne peut accéder
pas à la table car elle n&rsquo;existe plus. Le message n&rsquo;est pas très
explicite parce que la requête est en cours d&rsquo;exécution : le moteur a
déjà terminé le travail de parsing et de planification, il ne travaille
qu&rsquo;avec les OID qu&rsquo;il a récupéré du catalogue système à ce moment là.</p>
<p>Dans ce cas précis, obtenir ce message n&rsquo;est un problème de corruption
de la base ou du catalogue système.</p>
<!-- raw HTML omitted -->

        </div>
        

    


<div class="post-info">
    
        <div class="post-date">2011-08-04</div>
    
    <div class="post-taxonomies">
        
            <ul class="post-categories">
                
                    <li><a href="https://www.orgrim.net/categories/">PostgreSQL</a></li>
                
            </ul>
            
            
                <ul class="post-tags">
                    
                        <li><a href="https://www.orgrim.net/tags/postgresql">#postgresql</a></li>
                    
                        <li><a href="https://www.orgrim.net/tags/lock">#lock</a></li>
                    
                        <li><a href="https://www.orgrim.net/tags/pg_catalog">#pg_catalog</a></li>
                    
                </ul>
        
    </div>
</div>

    </article>

    

    


        </main>
        
            <footer class="common-footer">
    
    
        <ul class="language-select">

<li><a href="https://www.orgrim.net/">Français</a></li>

<li><a href="https://www.orgrim.net/en/">English</a></li>

</ul>
    

    <div class="common-footer-bottom">
        
        <div class="copyright">
            <p>© 2020<br>
            Propulsé par <a target="_blank" rel="noopener noreferrer" href="https://gohugo.io/">Hugo</a>, thème <a target="_blank" rel="noopener noreferrer" href="https://github.com/mitrichius/hugo-theme-anubis">Anubis</a>.
            </p>  
        </div> 

        

    



    <button class="theme-switcher">
        Thème sombre
    </button>

    <script>
    const STORAGE_KEY = 'user-color-scheme'
    const defaultTheme = "dark"

    let currentTheme
    let switchButton
    let autoDefinedScheme = window.matchMedia('(prefers-color-scheme: dark)')

    const autoChangeScheme = e => {
        currentTheme = e.matches ? 'dark' : 'light'
        document.documentElement.setAttribute('data-theme', currentTheme)
        changeButtonText()
    }

    document.addEventListener('DOMContentLoaded', function() {
        switchButton = document.querySelector('.theme-switcher')
        currentTheme = detectCurrentScheme()
        if (currentTheme == 'dark') {
            document.documentElement.setAttribute('data-theme', 'dark')
        }
        if (currentTheme == 'auto') {
            autoChangeScheme(autoDefinedScheme);
            autoDefinedScheme.addListener(autoChangeScheme);
        }
        changeButtonText()
        switchButton.addEventListener('click', switchTheme, false)
    })

    function detectCurrentScheme() {
        if (localStorage.getItem(STORAGE_KEY)) {
            return localStorage.getItem(STORAGE_KEY)
        } 
        if (defaultTheme) {
            return defaultTheme
        } 
        if (!window.matchMedia) {
            return 'light'
        } 
        if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
            return 'dark'
        }
        return 'light'
    }

    function changeButtonText()
    {   
        switchButton.textContent = currentTheme == 'dark' ?  "Thème léger" : "Thème sombre"
    }

    function switchTheme(e) {
        if (currentTheme == 'dark') {
            localStorage.setItem(STORAGE_KEY, 'light')
            document.documentElement.setAttribute('data-theme', 'light')
            currentTheme = 'light'
        } else {
            localStorage.setItem(STORAGE_KEY, 'dark')
            document.documentElement.setAttribute('data-theme', 'dark')
            currentTheme = 'dark'
        }
        changeButtonText()
    }
    </script>
   
    </div>
</footer>

        
    </div>
</body>
</html>
