<!DOCTYPE html>
<html lang="fr" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Load Balancing pour Patroni avec Keepalived | code. grind. sleep.</title>

<meta name="keywords" content="postgresql, ha, patroni, keepalived" />
<meta name="description" content="Patroni ne gère que le service PostgreSQL en pilotant la réplication. Les applications doivent déterminer quelle est l&rsquo;instance disponible en écriture et quelle est la ou les instances en lecture seule.
Pour fournir un point d&rsquo;accès unique, sous la forme d&rsquo;une adresse IP virtuelle, il faut ajouter un service ou mécanisme supplémentaire. Keepalived fournit ce service, il est également capable d&rsquo;équilibrer les connexions entre plusieurs instances.
Keepalived est un logiciel de haute-disponibilité et d&rsquo;équilibrage de charge reposant sur le noyau Linux.">
<meta name="author" content="">
<link rel="canonical" href="https://www.orgrim.net/post/2021-06-07-keepalived-load-balancing-patroni/" />
<link href="/assets/css/stylesheet.min.e5822bfcb21f8a202b16444ca56d1de6f331407cddd45f1de4a1e0af441b35e4.css" integrity="sha256-5YIr/LIfiiArFkRMpW0d5vMxQHzd1F8d5KHgr0QbNeQ=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://www.orgrim.net/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://www.orgrim.net/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://www.orgrim.net/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://www.orgrim.net/apple-touch-icon.png">
<link rel="mask-icon" href="https://www.orgrim.net/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.83.1" />
<link rel="alternate" hreflang="fr" href="https://www.orgrim.net/post/2021-06-07-keepalived-load-balancing-patroni/" />


<meta property="og:title" content="Load Balancing pour Patroni avec Keepalived" />
<meta property="og:description" content="Patroni ne gère que le service PostgreSQL en pilotant la réplication. Les applications doivent déterminer quelle est l&rsquo;instance disponible en écriture et quelle est la ou les instances en lecture seule.
Pour fournir un point d&rsquo;accès unique, sous la forme d&rsquo;une adresse IP virtuelle, il faut ajouter un service ou mécanisme supplémentaire. Keepalived fournit ce service, il est également capable d&rsquo;équilibrer les connexions entre plusieurs instances.
Keepalived est un logiciel de haute-disponibilité et d&rsquo;équilibrage de charge reposant sur le noyau Linux." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.orgrim.net/post/2021-06-07-keepalived-load-balancing-patroni/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-06-09T14:21:23&#43;02:00" />
<meta property="article:modified_time" content="2021-06-09T14:21:23&#43;02:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Load Balancing pour Patroni avec Keepalived"/>
<meta name="twitter:description" content="Patroni ne gère que le service PostgreSQL en pilotant la réplication. Les applications doivent déterminer quelle est l&rsquo;instance disponible en écriture et quelle est la ou les instances en lecture seule.
Pour fournir un point d&rsquo;accès unique, sous la forme d&rsquo;une adresse IP virtuelle, il faut ajouter un service ou mécanisme supplémentaire. Keepalived fournit ce service, il est également capable d&rsquo;équilibrer les connexions entre plusieurs instances.
Keepalived est un logiciel de haute-disponibilité et d&rsquo;équilibrage de charge reposant sur le noyau Linux."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://www.orgrim.net/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Load Balancing pour Patroni avec Keepalived",
      "item": "https://www.orgrim.net/post/2021-06-07-keepalived-load-balancing-patroni/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Load Balancing pour Patroni avec Keepalived",
  "name": "Load Balancing pour Patroni avec Keepalived",
  "description": "Patroni ne gère que le service PostgreSQL en pilotant la réplication. Les applications doivent déterminer quelle est l\u0026rsquo;instance disponible en écriture et quelle est la ou les instances en lecture seule.\nPour fournir un point d\u0026rsquo;accès unique, sous la forme d\u0026rsquo;une adresse IP virtuelle, il faut ajouter un service ou mécanisme supplémentaire. Keepalived fournit ce service, il est également capable d\u0026rsquo;équilibrer les connexions entre plusieurs instances.\nKeepalived est un logiciel de haute-disponibilité et d\u0026rsquo;équilibrage de charge reposant sur le noyau Linux.",
  "keywords": [
    "postgresql", "ha", "patroni", "keepalived"
  ],
  "articleBody": "Patroni ne gère que le service PostgreSQL en pilotant la réplication. Les applications doivent déterminer quelle est l’instance disponible en écriture et quelle est la ou les instances en lecture seule.\nPour fournir un point d’accès unique, sous la forme d’une adresse IP virtuelle, il faut ajouter un service ou mécanisme supplémentaire. Keepalived fournit ce service, il est également capable d’équilibrer les connexions entre plusieurs instances.\nKeepalived est un logiciel de haute-disponibilité et d’équilibrage de charge reposant sur le noyau Linux. Pour la haute disponibilité, il opère sur la couche réseau de niveau 3 et implémente le protocole VRRP.\nPour l’équilibrage de charge, Keepalived opére sur la couche réseau de niveau 4 et utilise la fonctionnalité IPVS du noyau Linux. Le load-balancing se fait soit par translation d’adresse (NAT) soit par re-routage (DR pour Direct Routing).\nLe NAT n’est possible que si les clients et la VIP sont dans un sous-réseau différent des serveurs PostgreSQL, ce qui rend la configuration plus complexe.\nLe Direct Routing fonctionne par réécriture de l’adresse MAC du paquet en provenance du client puis transmission au serveur PostgreSQL, forçant le serveur PostgreSQL à répondre directement au client. Cela impose de configurer la VIP sur chaque serveur PostgreSQL pour qu’ils répondent aux clients. Cela impose également de pouvoir contrôler la capacité à répondre aux requêtes ARP à la volée, car un seul serveur doit pourvoir être joint par les clients.\nAinsi, pour pouvoir faire du load balancing, il faut des machines dédiées à Keepalived. Le protocole VRRP permet de redonder le service de load balancing, en définissant le porteur d’une ou plusieurs adresses IP virtuelles parmi un ensemble de serveurs Keepalived. En cas d’indisponibilité d’un serveur Keepalived, l’adresse IP est activée sur un autre serveur Keepalived disponible.\nArchitecture Dans le contexte de la réplication PostgreSQL, il est possible de fournir une VIP pour le service en écriture. Du point de vue de keepalived, il s’agit d’une configuration de load balancing avec un seul serveur final actif, les autres étant exclus du fait qu’il sont en lecture seule.\nAvec une configuration de load balancing il est possible de répartir la charge en lecture seule à destination d’une unique VIP vers N instances PostgreSQL en réplication.\nUn service keepalived est déployé sur deux machines dédiées. Il permet aux applications d’accéder en lecture/écriture et lecture seule par l’intermédiaire de deux adresses IP.\nLe Direct Routing réduit le trafic réseau sur les machines keepalived en laissant les serveur PostgreSQL répondre directement aux clients, On configure alors les VIP sur tous les serveurs PostgreSQL via des interfaces réseau dummy qui ne provoquent pas de trafic ARP (on évite ainsi les conflits).\nEnfin, la détection du rôle de l’instance dans la réplication se fait par une requête HTTP sur le webservice de Patroni. Selon le résultat, keepalived autorise la redirection des paquets réseau vers la machine PostgreSQL.\nInstallation Keepalived est fournit dans les dépôts de paquets des distributions classiques, RHEL/CentOS, Debian et Ubuntu. Pour le monitoring du load balancing, l’outil ipvsadm est utile.\nL’installation ne concerne que les deux machines hébergeant Keepalived, il n’y a rien à installer de particulier sur les serveurs PostgreSQL.\nSur RHEL/CentOS :\n$ sudo yum install -y keepalived ipvsadm Sur Debian et Ubuntu :\n$ sudo apt install keepalived ipvsadm Si SELinux est activé sur RHEL/CentOS, il faut autoriser le trafic réseau pour Keepalived :\n$ sudo semanage boolean -m --on keepalived_connect_any Configuration Par la suite, la configuration du cluster est la suivante :\n Deux machines Keepalived ; Trois instances PostgreSQL, chacune hébergée sur un serveur distinct. Les adresses des nœuds sont : 10.0.2.3, 10.0.2.4, 10.0.2.5 ; L’adresse IP virtuelle pour le service PostgreSQL en écriture est : 10.0.2.10 ; L’adresse IP virtuelle pour le service PostgreSQL en lecture seule est : 10.0.2.11 ; Les adresses IP sont dans le même sous-réseau ; L’API REST de chaque service Patroni est configurée pour écouter sur l’adresse du nœud, sur le port TCP 8008, en HTTP.  La configuration du service se fait dans le fichier /etc/keepalived/keepalived.conf.\nPour chaque IP virtuelle utilisée comme point d’entrée pour un équilibrage entre plusieurs serveurs PostgreSQL, il faut définir :\n Une instance VRRP entre les deux machines Keepalived (aussi nommés par la suite load balancer) pour la redondance du service de load balancing ; Un « virtual server » avec N « real servers » correspondant au groupe d’instances PostgreSQL destinataires des connexions.  Le fichier de configuration de Keepalived est divisé en sections dont le contenu est entre accolades.\nTout d’abord, il faut définir un ensemble configuration dans la section global_defs :\nglobal_defs { router_id KAD1 vrrp_strict enable_script_security script_user root } Les paramètres sont les suivants :\n router_id KAD1 : l’identifiant alphanumérique du load-balancer, qui doit être unique. On les nomme KAD1 et KAD2. enable_script_security : keepalived refuse d’exécuter un script en utilisateur root si une partie de son chemin est accessible en écriture à d’autres utilisateurs que root. Cette sécurité permet de se prémunir contre des attaques par escalade de privilèges ; script_user root : utilisateur par défaut pour l’exécution des scripts de vérification ;  Les sections suivantes décrivent la suite de la configuration.\nAlgorithmes d’équilibrage L’équilibrage des connexions est réalisé grâce à la fonctionnalité « Linux Virtual Server » du noyau Linux qui possède différents algorithmes. Leur description est documentée dans la page de manuel de ipvsadm.\nCertains algorithmes sont pondérés, permettant d’adapter manuellement l’équilibrage selon la puissance de la machine PostgreSQL.\nPour répartir les connexions simplement, on choisit l’algorithme “Least-Connection” (lc).\nIP virtuelle pour les écritures Dans une configuration avec des load balancers dédiés, fournir une IP virtuelle pour l’instance PostgreSQL accessible en écriture revient à configurer un load balancing avec un seul serveur PostgreSQL disponible.\nLa redondance entre les load-balancers pour l’adresse IP virtuelle en écriture se fait dans une instance VRRP distincte de celle des lectures seules, de façon à pouvoir utiliser un load balancer pour les lectures/écritures et l’autre pour les lectures seules.\nOn définit donc une section vrrp_instance sur chaque load balancer :\n# KAD1 vrrp_instance PGRW { state MASTER interface eth0 virtual_router_id 1 priority 150 advert_int 1 virtual_ipaddress { 10.0.2.10/24 dev eth0 label eth0:1 } } Selon le load balancer, il faut adapter les paramètres suivants :\n state : MASTER ou BACKUP, définit la position initiale de l’IP virtuelle ; priority : 150 pour le load balancer principal et 100 pour le secondaire, le load balancer avec la priorité la plus élevée remporte l’élection et acquiert l’IP virtuelle.  Le paramètre virtual_router_id doit être le même sur les deux load balancers pour une instance donnée. Il permet de différencier cette instance de celle pour les lectures seules sur la même interface réseau.\nLes autres paramètres sont :\n interface : nom de l’interface réseau, doit être cohérente avec la sous-section virtual_ipaddress ; advert_int : intervalle en seconde entre les annonces VRRP ; virtual_ipaddress_: définition de l’adresse IP virtuelle, ici on la déclare comme alias numéro 1 de l’interface réseau.  Cela donne pour KAD2 :\n# KAD2 vrrp_instance PGRW { state BACKUP interface eth0 virtual_router_id 1 priority 100 advert_int 1 virtual_ipaddress { 10.0.2.10/24 dev eth0 label eth0:1 } } La configuration des redirections entre les nœuds du cluster Patroni se fait dans une section virtual_server :\nvirtual_server 10.0.2.10 5432 { lvs_method DR lb_algo lc # least connected protocol TCP delay_loop 1 delay_before_retry 1 connect_timeout 1 warmup 0 persistence_timeout 1 # Bloc à répéter pour chaque instance PostgreSQL real_server 10.0.2.x 5432 { weight 50 inhibit_on_failure HTTP_GET { connect_port 8008 url { path /primary status_code 200 } } } } Les paramètres sont :\n lvs_method : DR pour Direct Routing. Le load balancer remplace l’adresse MAC dans le paquet réseau à destination de l’IP virtuelle par celle du serveur PostgreSQL et réémet le paquet. Le serveur PostgreSQL répond alors directement au client. lb_algo : lc pour Least-Connection. Algorithme d’équilibrage de charge où les nouvelles connexions sont transmises aux serveurs PostgreSQL ayant le moins de connexion. Pour les lectures/écritures, l’algorithme a peu d’importance du fait qu’il n’y a toujours qu’une instance PostgreSQL accessible en écriture. protocol : TCP. Obligatoirement TCP, PostgreSQL utilise TCP.  Les paramètres relatifs aux délais et timeouts de connextion sont placés au minimum pour suivre les changements de topologie du cluster Patroni au plus vite :\n delay_loop : intervalle en second entre les vérifications de disponibilité des serveurs PostgreSQL ; delay_before_retry : temps d’attente en secondes après un échec de vérification, avant de réessayer ; connect_timeout : timeout de connection si l’instance ne réponds pas ; warmup : temps d’attente maximum en secondes pour la première vérification, on le place à 0 pour déasctiver ce délai ; persistence_timeout : positionné à 1, ce paramètre force le load balancer à ne pas conserver d’affinité entre les clients et les serveurs PostgreSQL. Cela permet de ne pas renvoyer un client sur la même instance après bascule parce qu’elle s’y était connecté auparavant, et ainsi garantir que la bascule est effective.  Enfin, il faut déclarer un sous-bloc real_server pour chaque instance PostgreSQL. On remarque que le port est celui de l’instance PostgreSQL. Le port du webservice de Patroni n’est utilisé que pour la vérification de disponibilité. Les paramètres sont :\n weight : poids du serveur dans le load balancing. Un poids à 0 désactive le serveur. Cette valeur est intéressante pour les algorithmes d’équilibrage de charge pondérés ; inhibit_on_failure : positionne le poids du serveur à 0 pour l’exclure du load balancing. Les instances replica auront donc ce poids et ne recevront pas de connexions en lecture/écriture.  Pour déterminer le rôle et vérifier la disponibilité de l’instance, on utilise une requête HTTP (HTTP_GET) sur le port du webservice Patroni (connect_port) : la méthode GET sur l’URL /primary doit renvoyer un code 200 pour que le load balancer envoie des connexions vers ce serveur.\nIP virtuelle pour les lectures seules Pour les lectures seules, la configuration utilise les mêmes principes que pour l’IP virtuelle de l’accès en écriture :\n On déclare une instance VRRP (avec virtual_router_id différent) un en plaçant la priorité sur le second load balancer, ainsi séparer le trafic entre les load balancers ; On déclare un LVS en Direct Routing avec les serveur PostgreSQL, seul le mécanisme de vérification change :  Pour n’équilibrer les lectures que sur les replica, on utilise HTTP_GET sur le webservice Patroni vers le chemin /replica ; Pour équilibrer vers tous les serveurs PostgreSQL disponibles, y compris le primaire, on utilise TCP_CHECK directement sur l’instance PostgreSQL, c’est plus performant.    Cela donne pour KAD1, par exemple :\nvrrp_instance PGRO { state BACKUP interface eth0 virtual_router_id 2 priority 100 advert_int 1 virtual_ipaddress { 10.0.2.11/24 dev eth0 label eth0:2 } } virtual_server 10.0.2.11 5432 { lvs_method DR lb_algo lc # least connected protocol TCP delay_loop 1 delay_before_retry 1 connect_timeout 1 warmup 0 persistence_timeout 0 real_server 10.0.2.3 5432 { weight 50 inhibit_on_failure HTTP_GET { connect_port 8008 url { path /replica status_code 200 } } } real_server 10.0.2.4 5432 { weight 50 inhibit_on_failure HTTP_GET { connect_port 8008 url { path /replica status_code 200 } } } real_server 10.0.2.5 5432 { weight 50 inhibit_on_failure HTTP_GET { connect_port 8008 url { path /replica status_code 200 } } } } Si on souhaite inclure l’instance primaire, les blocs real_server deviennent :\nreal_server 10.0.2.x 5432 { weight 50 inhibit_on_failure TCP_CHECK { connect_timeout 1 } } Interfaces dummy sur les serveurs PostgreSQL Les opérations suivantes sont à réaliser sur les serveurs PostgreSQL seulement.\nPour qu’ils soient en mesure de répondre aux clients, les serveurs PostgreSQL doivent se considérer comme destinataires des paquets réseaux à destination des VIP, sans générer de trafic ARP pour ces adresses. Utiliser une interface réseau dummy pour placer les VIP sur les serveurs PostgreSQL est dans ce cas la solution la plus simple.\nConfigurer le chargement du module dummy au démarrage de la machine en créant le fichier /etc/modules-load.d/dummy.conf avec le contenu :\ndummy Configurer les options de chargement du module dans /etc/modprobe.d/z-dummy.conf :\noptions dummy numdummies=1 Charger le module :\nmodprobe dummy Sur RHEL/CentOS 7, créer un fichier de configuration pour l’interface, il doit être après le fichier de l’interface principale dans l’ordre alphabétique, sinon la route par défaut sera placée sur l’interface dummy :\nPour l’IP virtuelle de l’accès en lecture/écriture, /etc/sysconfig/network-scripts/ifcfg-vip1 :\nDEVICE=dummy0 DEFROUTE=no BOOTPROTO=none IPADDR=10.0.2.10 NETMASK=255.255.255.0 ONBOOT=yes TYPE=Ethernet NM_CONTROLLED=no Pour l’IP virtuelle de l’accès en lecture seule, /etc/sysconfig/network-scripts/ifcfg-vip2 :\nDEVICE=dummy0:0 DEFROUTE=no BOOTPROTO=none IPADDR=10.0.2.11 NETMASK=255.255.255.0 ONBOOT=yes TYPE=Ethernet NM_CONTROLLED=no Activer les interfaces :\n$ sudo ifup vip1 $ sudo ifup vip2 Sur RHEL/CentOS 8, utiliser nmcli :\n$ sudo nmcli connection add type dummy ifname dummy0 \\ ipv4.method manual ipv4.addresses \"10.0.2.10/24, 10.0.2.11/24\" $ sudo nmcli connection up dummy-dummy0 Sur Debian/Ubuntu, dans /etc/network/interfaces :\nauto dummy0 iface dummy0 inet static address 10.0.2.10/24 auto dummy0:0 iface dummy0:0 inet static address 10.0.2.11/24 Activer les interfaces :\n$ sudo ifup vip1 $ sudo ifup vip2 Activation du service Le service est géré par systemd :\n$ sudo systemctl enable --now keepalived Les messages et traces de Keepalived sont écrites dans syslog et apparaissent dans le journal.\nLes modifications de configuration, comme un ajout ou une suppression de real_server requièrent seulement un rechargement du service :\n$ sudo systemctl reload keepalived Supervision On peut configurer les instances VRRP pour que des notifications soit envoyées sur les changements d’état. Cela peut se faire par mail (SMTP) ou par l’exécution de scripts (paramètres notify_master, notify_backup, notify_fault, etc)\nPour les blocs real_server, les paramètres sont notify_up et notify_down.\nLa syntaxe des paramètres de notification est :\nnotify_XXX | [username [groupname]] Pour examiner l’équilibrage de charge, l’outil ipvsadm est intéressant, par exemple pour la VIP en écriture (le poids indique l’instance primaire) :\n# ipvsadm -l -n IP Virtual Server version 1.2.1 (size=4096) Prot LocalAddress:Port Scheduler Flags - RemoteAddress:Port Forward Weight ActiveConn InActConn TCP 10.0.2.10:5432 lc - 10.0.2.3:5432 Route 0 0 0 - 10.0.2.4:5432 Route 50 0 0 - 10.0.2.5:5432 Route 0 0 0 Tests Les tests ont été réalisés avec la configuration décrite précédemment sur des machines virtuelles KVM en CentOS 8.2, avec Keepalived v2.1.5 et PostgreSQL 13.3.\nEcritures et bascule Préparer un utilisateur et une base de données pour les tests :\n$ export PGPASSWORD=\"xxxx\" $ createuser -h 10.0.2.10 -U postgres -P my_user $ createdb -h 10.0.2.10 -U postgres my_db $ psql -h 10.0.2.10 -U my_user -c \"create table t1 (i int)\" my_db Lancer une boucle qui insère une ligne toutes les secondes :\n$ while $(true); \\ do psql -X -h 10.0.2.10 -U my_user -c \"insert into t1 values (1)\" my_db; \\ sleep 1; done Voici l’état du load balancing sur la machine keepalived qui porte l’IP virtuelle en écriture (on remarque le poids à 50 pour le Leader) :\n$ ipvsadm -l -n IP Virtual Server version 1.2.1 (size=4096) Prot LocalAddress:Port Scheduler Flags - RemoteAddress:Port Forward Weight ActiveConn InActConn TCP 10.0.2.10:5432 lc - 10.0.2.3:5432 Route 0 0 0 - 10.0.2.4:5432 Route 0 0 0 - 10.0.2.5:5432 Route 50 0 9 TCP 10.0.2.11:5432 lc - 10.0.2.3:5432 Route 50 0 0 - 10.0.2.4:5432 Route 50 0 0 - 10.0.2.5:5432 Route 50 0 0 On provoque alors une bascule coté Patroni :\n$ patronictl switchover Lorsque le cluster est revenu à un état stable, ipvsadm montre l’évolution des poids, le Leader à changé :\n$ ipvsadm -l -n IP Virtual Server version 1.2.1 (size=4096) Prot LocalAddress:Port Scheduler Flags - RemoteAddress:Port Forward Weight ActiveConn InActConn TCP 10.0.2.10:5432 lc - 10.0.2.3:5432 Route 50 0 0 - 10.0.2.4:5432 Route 0 0 0 - 10.0.2.5:5432 Route 0 9 3 TCP 10.0.2.11:5432 lc - 10.0.2.3:5432 Route 50 0 0 - 10.0.2.4:5432 Route 50 0 0 - 10.0.2.5:5432 Route 50 0 0 Du côté de « l’application », on a les traces suivantes, montrant la bascule, qui a duré environ 15 secondes :\nINSERT 0 1 INSERT 0 1 INSERT 0 1 INSERT 0 1 psql: error: FATAL: the database system is shutting down FATAL: the database system is shutting down psql: error: FATAL: the database system is shutting down FATAL: the database system is shutting down psql: error: FATAL: the database system is shutting down FATAL: the database system is shutting down psql: error: could not connect to server: Connection refused Is the server running on host \"10.0.2.10\" and accepting TCP/IP connections on port 5432? psql: error: could not connect to server: Connection refused Is the server running on host \"10.0.2.10\" and accepting TCP/IP connections on port 5432? psql: error: could not connect to server: Connection refused Is the server running on host \"10.0.2.10\" and accepting TCP/IP connections on port 5432? psql: error: could not connect to server: Connection refused Is the server running on host \"10.0.2.10\" and accepting TCP/IP connections on port 5432? psql: error: could not connect to server: Connection refused Is the server running on host \"10.0.2.10\" and accepting TCP/IP connections on port 5432? psql: error: could not connect to server: Connection refused Is the server running on host \"10.0.2.10\" and accepting TCP/IP connections on port 5432? psql: error: could not connect to server: Connection refused Is the server running on host \"10.0.2.10\" and accepting TCP/IP connections on port 5432? psql: error: could not connect to server: Connection refused Is the server running on host \"10.0.2.10\" and accepting TCP/IP connections on port 5432? ERROR: cannot execute INSERT in a read-only transaction ERROR: cannot execute INSERT in a read-only transaction psql: error: could not connect to server: Connection refused Is the server running on host \"10.0.2.10\" and accepting TCP/IP connections on port 5432? INSERT 0 1 INSERT 0 1 INSERT 0 1 INSERT 0 1 Equilibrage de charge .notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Remarque\nLa machine de test n’étant pas assez puissante (surtout au niveau du nombre de CPU/Core), le résultat du bench importe moins que la répartition des connexions entre les machines.\n Initialiser la base de données pour pgbench :\n$ pgbench -h 10.0.2.10 -U my_user -i my_db Lancer un pgbench en lecture seule sur l’instance primaire en lecture/écriture :\n$ pgbench -h 10.0.2.10 -U my_user -n -S -j 4 -c 75 -T 30 my_db transaction type: scaling factor: 1 query mode: simple number of clients: 75 number of threads: 4 duration: 30 s number of transactions actually processed: 176106 latency average = 12.843 ms tps = 5839.685783 (including connections establishing) tps = 5848.370529 (excluding connections establishing) Durant l’exécution, ipvsadm montre la répartition des connexions :\n$ ipvsadm -l -n IP Virtual Server version 1.2.1 (size=4096) Prot LocalAddress:Port Scheduler Flags - RemoteAddress:Port Forward Weight ActiveConn InActConn TCP 10.0.2.10:5432 lc - 10.0.2.3:5432 Route 50 75 1 - 10.0.2.4:5432 Route 0 0 0 - 10.0.2.5:5432 Route 0 0 0 TCP 10.0.2.11:5432 lc - 10.0.2.3:5432 Route 50 0 0 - 10.0.2.4:5432 Route 50 0 0 - 10.0.2.5:5432 Route 50 0 0 Puis sur l’IP virtuelle en lecture seule :\n$ pgbench -h 10.0.2.11 -U my_user -n -S -j 4 -c 75 -T 30 my_db transaction type: scaling factor: 1 query mode: simple number of clients: 75 number of threads: 4 duration: 30 s number of transactions actually processed: 220756 latency average = 10.221 ms tps = 7337.509985 (including connections establishing) tps = 7343.683211 (excluding connections establishing) Durant l’exécution, ipvsadm montre la répartition des connexions entre les instances PostgreSQL, prouvant l’équilibrage de charge :\n$ ipvsadm -l -n IP Virtual Server version 1.2.1 (size=4096) Prot LocalAddress:Port Scheduler Flags - RemoteAddress:Port Forward Weight ActiveConn InActConn TCP 10.0.2.10:5432 lc - 10.0.2.3:5432 Route 50 0 0 - 10.0.2.4:5432 Route 0 0 0 - 10.0.2.5:5432 Route 0 0 0 TCP 10.0.2.11:5432 lc - 10.0.2.3:5432 Route 50 25 0 - 10.0.2.4:5432 Route 50 25 0 - 10.0.2.5:5432 Route 50 25 0 Fichiers de configuration complets Load balancer KAD1 global_defs { router_id KAD1 vrrp_strict enable_script_security script_user root } vrrp_instance PGRW { state MASTER interface eth0 virtual_router_id 1 priority 150 advert_int 1 virtual_ipaddress { 10.0.2.10/24 dev eth0 label eth0:1 } } virtual_server 10.0.2.10 5432 { delay_loop 1 lvs_method DR lb_algo lc # least connected persistence_timeout 1 protocol TCP delay_before_retry 1 connect_timeout 1 warmup 0 real_server 10.0.2.3 5432 { weight 50 inhibit_on_failure HTTP_GET { connect_port 8010 url { path /primary status_code 200 } } } real_server 10.0.2.4 5432 { weight 50 inhibit_on_failure HTTP_GET { connect_port 8010 url { path /primary status_code 200 } } } real_server 10.0.2.5 5432 { weight 50 inhibit_on_failure HTTP_GET { connect_port 8010 url { path /primary status_code 200 } } } } vrrp_instance PGRO { state BACKUP interface eth0 virtual_router_id 2 priority 100 advert_int 1 virtual_ipaddress { 10.0.2.11/24 dev eth0 label eth0:2 } } virtual_server 10.0.2.11 5432 { delay_loop 1 lvs_method DR lb_algo lc # least connected persistence_timeout 1 protocol TCP delay_before_retry 1 connect_timeout 1 warmup 0 real_server 10.0.2.3 5432 { weight 50 inhibit_on_failure TCP_CHECK { connect_timeout 1 } } real_server 10.0.2.4 5432 { weight 50 inhibit_on_failure TCP_CHECK { connect_timeout 1 } } real_server 10.0.2.5 5432 { weight 50 inhibit_on_failure TCP_CHECK { connect_timeout 1 } } } Load balancer KAD2 global_defs { router_id KAD2 vrrp_strict enable_script_security script_user root } vrrp_instance PGRW { state BACKUP interface eth0 virtual_router_id 1 priority 100 advert_int 1 virtual_ipaddress { 10.0.2.10/24 dev eth0 label eth0:1 } } virtual_server 10.0.2.10 5432 { delay_loop 1 lvs_method DR lb_algo lc # least connected persistence_timeout 1 protocol TCP delay_before_retry 1 connect_timeout 1 warmup 0 real_server 10.0.2.3 5432 { weight 50 inhibit_on_failure HTTP_GET { connect_port 8010 url { path /primary status_code 200 } } } real_server 10.0.2.4 5432 { weight 50 inhibit_on_failure HTTP_GET { connect_port 8010 url { path /primary status_code 200 } } } real_server 10.0.2.5 5432 { weight 50 inhibit_on_failure HTTP_GET { connect_port 8010 url { path /primary status_code 200 } } } } vrrp_instance PGRO { state MASTER interface eth0 virtual_router_id 2 priority 150 advert_int 1 virtual_ipaddress { 10.0.2.11/24 dev eth0 label eth0:2 } } virtual_server 10.0.2.11 5432 { lvs_method DR lb_algo lc # least connected persistence_timeout 1 protocol TCP delay_loop 1 delay_before_retry 1 connect_timeout 1 warmup 0 real_server 10.0.2.3 5432 { weight 50 inhibit_on_failure TCP_CHECK { connect_timeout 1 } } real_server 10.0.2.4 5432 { weight 50 inhibit_on_failure TCP_CHECK { connect_timeout 1 } } real_server 10.0.2.5 5432 { weight 50 inhibit_on_failure TCP_CHECK { connect_timeout 1 } } } ",
  "wordCount" : "3658",
  "inLanguage": "fr",
  "datePublished": "2021-06-09T14:21:23+02:00",
  "dateModified": "2021-06-09T14:21:23+02:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.orgrim.net/post/2021-06-07-keepalived-load-balancing-patroni/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "code. grind. sleep.",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.orgrim.net/favicon.ico"
    }
  }
}
</script>





</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }
    </style>

</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.orgrim.net/" accesskey="h" title="code. grind. sleep. (Alt + H)">code. grind. sleep.</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                
                

                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://www.orgrim.net/en/" title="English"
                            aria-label="English">En</a>
                    </li>
                </ul>
            </span>
        </div>
        <ul id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://www.orgrim.net/post" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://www.orgrim.net/categories" title="Catégories">
                    <span>Catégories</span>
                </a>
            </li>
            <li>
                <a href="https://www.orgrim.net/tags" title="Tags">
                    <span>Tags</span>
                </a>
            </li></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">

    <h1 class="post-title">
      Load Balancing pour Patroni avec Keepalived
    </h1>
    <div class="post-meta">2021-06-09&nbsp;·&nbsp;18 min


</div>
  </header> 

  <div class="toc">
    <details >
      <summary accesskey="c" title="(Alt + C)">
        <div class="details">Table of Contents</div>
      </summary>
      <div class="inner"><ul><li>
        <a href="#architecture" aria-label="Architecture">Architecture</a></li><li>
        <a href="#installation" aria-label="Installation">Installation</a></li><li>
        <a href="#configuration" aria-label="Configuration">Configuration</a><ul>
            <li>
        <a href="#algorithmes-d%c3%a9quilibrage" aria-label="Algorithmes d&amp;rsquo;équilibrage">Algorithmes d&rsquo;équilibrage</a></li><li>
        <a href="#ip-virtuelle-pour-les-%c3%a9critures" aria-label="IP virtuelle pour les écritures">IP virtuelle pour les écritures</a></li><li>
        <a href="#ip-virtuelle-pour-les-lectures-seules" aria-label="IP virtuelle pour les lectures seules">IP virtuelle pour les lectures seules</a></li><li>
        <a href="#interfaces-dummy-sur-les-serveurs-postgresql" aria-label="Interfaces dummy sur les serveurs PostgreSQL">Interfaces dummy sur les serveurs PostgreSQL</a></li><li>
        <a href="#activation-du-service" aria-label="Activation du service">Activation du service</a></li></ul>
    </li><li>
        <a href="#supervision" aria-label="Supervision">Supervision</a></li><li>
        <a href="#tests" aria-label="Tests">Tests</a><ul>
            <li>
        <a href="#ecritures-et-bascule" aria-label="Ecritures et bascule">Ecritures et bascule</a></li><li>
        <a href="#equilibrage-de-charge" aria-label="Equilibrage de charge">Equilibrage de charge</a></li></ul>
    </li><li>
        <a href="#fichiers-de-configuration-complets" aria-label="Fichiers de configuration complets">Fichiers de configuration complets</a><ul>
            <li>
        <a href="#load-balancer-kad1" aria-label="Load balancer KAD1">Load balancer KAD1</a></li><li>
        <a href="#load-balancer-kad2" aria-label="Load balancer KAD2">Load balancer KAD2</a></li></ul>
</li></ul>
      </div>
    </details>
  </div>
  <div class="post-content">
<p>Patroni ne gère que le service PostgreSQL en pilotant la réplication. Les
applications doivent déterminer quelle est l&rsquo;instance disponible en écriture et
quelle est la ou les instances en lecture seule.</p>
<p>Pour fournir un point d&rsquo;accès unique, sous la forme d&rsquo;une adresse IP virtuelle,
il faut ajouter un service ou mécanisme supplémentaire. Keepalived fournit ce
service, il est également capable d&rsquo;équilibrer les connexions entre plusieurs
instances.</p>
<p>Keepalived est un logiciel de haute-disponibilité et d&rsquo;équilibrage de charge
reposant sur le noyau Linux. Pour la haute disponibilité, il opère sur la
couche réseau de niveau 3 et implémente le protocole VRRP.</p>
<p>Pour l&rsquo;équilibrage de charge, Keepalived opére sur la couche réseau de niveau 4
et utilise la fonctionnalité IPVS du noyau Linux. Le load-balancing se fait soit par
translation d&rsquo;adresse (NAT) soit par re-routage (DR pour Direct Routing).</p>
<p>Le NAT n&rsquo;est possible que si les clients et la VIP sont dans un sous-réseau
différent des serveurs PostgreSQL, ce qui rend la configuration plus complexe.</p>
<p>Le <em>Direct Routing</em> fonctionne par réécriture de l&rsquo;adresse MAC du paquet en
provenance du client puis transmission au serveur PostgreSQL, forçant le
serveur PostgreSQL à répondre directement au client. Cela impose de configurer
la VIP sur chaque serveur PostgreSQL pour qu&rsquo;ils répondent aux clients. Cela
impose également de pouvoir contrôler la capacité à répondre aux requêtes ARP à
la volée, car un seul serveur doit pourvoir être joint par les clients.</p>
<p>Ainsi, pour pouvoir faire du <em>load balancing</em>, il faut des machines dédiées à
Keepalived. Le protocole VRRP permet de redonder le service de <em>load balancing</em>,
en définissant le porteur d&rsquo;une ou plusieurs adresses IP virtuelles parmi un
ensemble de serveurs Keepalived.  En cas d&rsquo;indisponibilité d&rsquo;un serveur
Keepalived, l&rsquo;adresse IP est activée sur un autre serveur Keepalived
disponible.</p>
<h2 id="architecture">Architecture<a hidden class="anchor" aria-hidden="true" href="#architecture">#</a></h2>
<p>Dans le contexte de la réplication PostgreSQL, il est possible de fournir une
VIP pour le service en écriture. Du point de vue de keepalived, il s&rsquo;agit d&rsquo;une
configuration de <em>load balancing</em> avec un seul serveur final actif, les autres
étant exclus du fait qu&rsquo;il sont en lecture seule.</p>
<p>Avec une configuration de <em>load balancing</em> il est possible de répartir la charge
en lecture seule à destination d&rsquo;une unique VIP vers <em>N</em> instances PostgreSQL en
réplication.</p>
<p><img loading="lazy" src="archi_lb.png" alt="Architecture Keepalived"  />
</p>
<p>Un service keepalived est déployé sur deux machines dédiées. Il permet aux
applications d&rsquo;accéder en lecture/écriture et lecture seule par l&rsquo;intermédiaire
de deux adresses IP.</p>
<p>Le <em>Direct Routing</em> réduit le trafic réseau sur les machines keepalived en
laissant les serveur PostgreSQL répondre directement aux clients, On configure
alors les VIP sur tous les serveurs PostgreSQL via des interfaces réseau
<code>dummy</code> qui ne provoquent pas de trafic ARP (on évite ainsi les conflits).</p>
<p>Enfin, la détection du rôle de l&rsquo;instance dans la réplication se fait par une
requête HTTP sur le webservice de Patroni. Selon le résultat, keepalived
autorise la redirection des paquets réseau vers la machine PostgreSQL.</p>
<h2 id="installation">Installation<a hidden class="anchor" aria-hidden="true" href="#installation">#</a></h2>
<p>Keepalived est fournit dans les dépôts de paquets des distributions classiques,
RHEL/CentOS, Debian et Ubuntu. Pour le monitoring du <em>load balancing</em>, l&rsquo;outil <code>ipvsadm</code> est
utile.</p>
<p>L&rsquo;installation ne concerne que les deux machines hébergeant Keepalived, il n&rsquo;y
a rien à installer de particulier sur les serveurs PostgreSQL.</p>
<p>Sur RHEL/CentOS :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">$ sudo yum install -y keepalived ipvsadm
</code></pre></div><p>Sur Debian et Ubuntu :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">$ sudo apt install keepalived ipvsadm
</code></pre></div><p>Si SELinux est activé sur RHEL/CentOS, il faut autoriser le trafic réseau pour
Keepalived :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">$ sudo semanage boolean -m --on keepalived_connect_any
</code></pre></div><h2 id="configuration">Configuration<a hidden class="anchor" aria-hidden="true" href="#configuration">#</a></h2>
<p>Par la suite, la configuration du cluster est la suivante :</p>
<ul>
<li>Deux machines Keepalived ;</li>
<li>Trois instances PostgreSQL, chacune hébergée sur un serveur distinct. Les
adresses des nœuds sont : <code>10.0.2.3</code>, <code>10.0.2.4</code>, <code>10.0.2.5</code> ;</li>
<li>L&rsquo;adresse IP virtuelle pour le service PostgreSQL <strong>en écriture</strong> est : <code>10.0.2.10</code> ;</li>
<li>L&rsquo;adresse IP virtuelle pour le service PostgreSQL <strong>en lecture seule</strong> est : <code>10.0.2.11</code> ;</li>
<li>Les adresses IP sont dans le même sous-réseau ;</li>
<li>L&rsquo;API REST de chaque service Patroni est configurée pour écouter sur l&rsquo;adresse
du nœud, sur le port TCP 8008, en HTTP.</li>
</ul>
<p>La configuration du service se fait dans le fichier
<code>/etc/keepalived/keepalived.conf</code>.</p>
<p>Pour chaque IP virtuelle utilisée comme point d&rsquo;entrée pour un équilibrage
entre plusieurs serveurs PostgreSQL, il faut définir :</p>
<ul>
<li>Une instance VRRP entre les deux machines Keepalived (aussi nommés par la
suite load balancer) pour la redondance du service de <em>load balancing</em> ;</li>
<li>Un « virtual server » avec <em>N</em> « real servers » correspondant au groupe
d&rsquo;instances PostgreSQL destinataires des connexions.</li>
</ul>
<p>Le fichier de configuration de Keepalived est divisé en sections dont le
contenu est entre accolades.</p>
<p>Tout d&rsquo;abord, il faut définir un ensemble configuration dans la section
<code>global_defs</code> :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">global_defs {
  router_id KAD1
  vrrp_strict
  enable_script_security
  script_user root
}
</code></pre></div><p>Les paramètres sont les suivants :</p>
<ul>
<li><code>router_id KAD1</code> : l&rsquo;identifiant alphanumérique du <em>load-balancer</em>, qui doit
être <strong>unique</strong>. On les nomme <code>KAD1</code> et <code>KAD2</code>.</li>
<li><code>enable_script_security</code> : keepalived refuse d&rsquo;exécuter un script en
utilisateur <code>root</code> si une partie de son chemin est accessible en écriture à
d&rsquo;autres utilisateurs que <code>root</code>. Cette sécurité permet de se prémunir
contre des attaques par escalade de privilèges ;</li>
<li><code>script_user root</code> : utilisateur par défaut pour l&rsquo;exécution des scripts de
vérification ;</li>
</ul>
<p>Les sections suivantes décrivent la suite de la configuration.</p>
<h3 id="algorithmes-déquilibrage">Algorithmes d&rsquo;équilibrage<a hidden class="anchor" aria-hidden="true" href="#algorithmes-déquilibrage">#</a></h3>
<p>L&rsquo;équilibrage des connexions est réalisé grâce à la fonctionnalité « Linux
Virtual Server » du noyau Linux qui possède différents algorithmes. Leur
description est documentée dans la page de manuel de <code>ipvsadm</code>.</p>
<p>Certains algorithmes sont pondérés, permettant d&rsquo;adapter manuellement
l&rsquo;équilibrage selon la puissance de la machine PostgreSQL.</p>
<p>Pour répartir les connexions simplement, on choisit l&rsquo;algorithme
&ldquo;Least-Connection&rdquo; (<code>lc</code>).</p>
<h3 id="ip-virtuelle-pour-les-écritures">IP virtuelle pour les écritures<a hidden class="anchor" aria-hidden="true" href="#ip-virtuelle-pour-les-écritures">#</a></h3>
<p>Dans une configuration avec des load balancers dédiés, fournir une IP virtuelle
pour l&rsquo;instance PostgreSQL accessible en écriture revient à configurer un load
balancing avec un seul serveur PostgreSQL disponible.</p>
<p>La redondance entre les load-balancers pour l&rsquo;adresse IP virtuelle en écriture
se fait dans une instance VRRP distincte de celle des lectures seules, de façon
à pouvoir utiliser un load balancer pour les lectures/écritures et l&rsquo;autre pour
les lectures seules.</p>
<p>On définit donc une section <code>vrrp_instance</code> sur chaque load balancer :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback"># KAD1
vrrp_instance PGRW {
  state MASTER
  interface eth0
  virtual_router_id 1
  priority 150
  advert_int 1
  virtual_ipaddress {
    10.0.2.10/24 dev eth0 label eth0:1
  }
}
</code></pre></div><p>Selon le load balancer, il faut adapter les paramètres suivants :</p>
<ul>
<li><code>state</code> : MASTER ou BACKUP, définit la position initiale de l&rsquo;IP virtuelle ;</li>
<li><code>priority</code> : 150 pour le load balancer principal et 100 pour le secondaire, le
load balancer avec la priorité la plus élevée remporte l&rsquo;élection et acquiert
l&rsquo;IP virtuelle.</li>
</ul>
<p>Le paramètre <code>virtual_router_id</code> doit être le même sur les deux load balancers
pour une instance donnée. Il permet de différencier cette instance de celle
pour les lectures seules sur la même interface réseau.</p>
<p>Les autres paramètres sont :</p>
<ul>
<li><code>interface</code> : nom de l&rsquo;interface réseau, doit être cohérente avec la
sous-section <code>virtual_ipaddress</code> ;</li>
<li><code>advert_int</code> : intervalle en seconde entre les annonces VRRP ;</li>
<li><code>virtual_ipaddress</code>_: définition de l&rsquo;adresse IP virtuelle, ici on la déclare
comme alias numéro 1 de l&rsquo;interface réseau.</li>
</ul>
<p>Cela donne pour KAD2 :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback"># KAD2
vrrp_instance PGRW {
  state BACKUP
  interface eth0
  virtual_router_id 1
  priority 100
  advert_int 1
  virtual_ipaddress {
    10.0.2.10/24 dev eth0 label eth0:1
  }
}
</code></pre></div><p>La configuration des redirections entre les nœuds du cluster Patroni se fait
dans une section <code>virtual_server</code> :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">virtual_server 10.0.2.10 5432 {
  lvs_method DR
  lb_algo lc # least connected
  protocol TCP

  delay_loop 1
  delay_before_retry 1
  connect_timeout 1
  warmup 0
  persistence_timeout 1

  # Bloc à répéter pour chaque instance PostgreSQL
  real_server 10.0.2.x 5432 {
    weight 50
    inhibit_on_failure
    HTTP_GET {
      connect_port 8008
      url {
        path /primary
        status_code 200
      }
    }
  }
}
</code></pre></div><p>Les paramètres sont :</p>
<ul>
<li><code>lvs_method</code> : <code>DR</code> pour <em>Direct Routing</em>. Le load balancer remplace l&rsquo;adresse
MAC dans le paquet réseau à destination de l&rsquo;IP virtuelle par celle du
serveur PostgreSQL et réémet le paquet. Le serveur PostgreSQL répond alors
directement au client.</li>
<li><code>lb_algo</code> : <code>lc</code> pour <em>Least-Connection</em>. Algorithme d&rsquo;équilibrage de charge où
les nouvelles connexions sont transmises aux serveurs PostgreSQL ayant le
moins de connexion. Pour les lectures/écritures, l&rsquo;algorithme a peu
d&rsquo;importance du fait qu&rsquo;il n&rsquo;y a toujours qu&rsquo;une instance PostgreSQL
accessible en écriture.</li>
<li><code>protocol</code> : <code>TCP</code>. Obligatoirement TCP, PostgreSQL utilise TCP.</li>
</ul>
<p>Les paramètres relatifs aux délais et timeouts de connextion sont placés au
minimum pour suivre les changements de topologie du cluster Patroni au plus
vite :</p>
<ul>
<li><code>delay_loop</code> : intervalle en second entre les vérifications de disponibilité des
serveurs PostgreSQL ;</li>
<li><code>delay_before_retry</code> : temps d&rsquo;attente en secondes après un échec de
vérification, avant de réessayer ;</li>
<li><code>connect_timeout</code> : timeout de connection si l&rsquo;instance ne réponds pas ;</li>
<li><code>warmup</code> : temps d&rsquo;attente maximum en secondes pour la première vérification,
on le place à 0 pour déasctiver ce délai ;</li>
<li><code>persistence_timeout</code> : positionné à 1, ce paramètre force le load balancer à
ne pas conserver d&rsquo;affinité entre les clients et les serveurs
PostgreSQL. Cela permet de ne pas renvoyer un client sur la même instance
après bascule parce qu&rsquo;elle s&rsquo;y était connecté auparavant, et ainsi garantir
que la bascule est effective.</li>
</ul>
<p>Enfin, il faut déclarer un sous-bloc <code>real_server</code> pour <strong>chaque</strong> instance
PostgreSQL. On remarque que le port est celui de l&rsquo;instance PostgreSQL. Le port
du webservice de Patroni n&rsquo;est utilisé que pour la vérification de
disponibilité. Les paramètres sont :</p>
<ul>
<li><code>weight</code> : poids du serveur dans le load balancing. Un poids à <code>0</code> désactive le
serveur. Cette valeur est intéressante pour les algorithmes d&rsquo;équilibrage de
charge pondérés ;</li>
<li><code>inhibit_on_failure</code> : positionne le poids du serveur à <code>0</code> pour l&rsquo;exclure du
load balancing. Les instances replica auront donc ce poids et ne recevront
pas de connexions en lecture/écriture.</li>
</ul>
<p>Pour déterminer le rôle et vérifier la disponibilité de l&rsquo;instance, on utilise
une requête HTTP (<code>HTTP_GET</code>) sur le port du webservice Patroni
(<code>connect_port</code>) : la méthode GET sur l&rsquo;URL <code>/primary</code> doit renvoyer un code
200 pour que le load balancer envoie des connexions vers ce serveur.</p>
<h3 id="ip-virtuelle-pour-les-lectures-seules">IP virtuelle pour les lectures seules<a hidden class="anchor" aria-hidden="true" href="#ip-virtuelle-pour-les-lectures-seules">#</a></h3>
<p>Pour les lectures seules, la configuration utilise les mêmes principes que pour
l&rsquo;IP virtuelle de l&rsquo;accès en écriture :</p>
<ul>
<li>On déclare une instance VRRP (avec <code>virtual_router_id</code> différent) un en
plaçant la priorité sur le second load balancer, ainsi séparer le trafic
entre les load balancers ;</li>
<li>On déclare un LVS en Direct Routing avec les serveur PostgreSQL, seul le
mécanisme de vérification change :
<ul>
<li>Pour n&rsquo;équilibrer les lectures que sur les replica, on utilise <code>HTTP_GET</code> sur
le webservice Patroni vers le chemin <code>/replica</code> ;</li>
<li>Pour équilibrer vers tous les serveurs PostgreSQL disponibles, y compris le
primaire, on utilise <code>TCP_CHECK</code> directement sur l&rsquo;instance PostgreSQL, c&rsquo;est
plus performant.</li>
</ul>
</li>
</ul>
<p>Cela donne pour KAD1, par exemple :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">vrrp_instance PGRO {
  state BACKUP
  interface eth0
  virtual_router_id 2
  priority 100
  advert_int 1
  virtual_ipaddress {
    10.0.2.11/24 dev eth0 label eth0:2
  }
}

virtual_server 10.0.2.11 5432 {
  lvs_method DR
  lb_algo lc # least connected
  protocol TCP

  delay_loop 1
  delay_before_retry 1
  connect_timeout 1
  warmup 0
  persistence_timeout 0

  real_server 10.0.2.3 5432 {
    weight 50
    inhibit_on_failure
    HTTP_GET {
      connect_port 8008
      url {
        path /replica
        status_code 200
      }
    }
  }
  
  real_server 10.0.2.4 5432 {
    weight 50
    inhibit_on_failure
    HTTP_GET {
      connect_port 8008
      url {
        path /replica
        status_code 200
      }
    }
  }
  
  real_server 10.0.2.5 5432 {
    weight 50
    inhibit_on_failure
    HTTP_GET {
      connect_port 8008
      url {
        path /replica
        status_code 200
      }
    }
  }
}
</code></pre></div><p>Si on souhaite inclure l&rsquo;instance primaire, les blocs <code>real_server</code> deviennent :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">real_server 10.0.2.x 5432 {
  weight 50
  inhibit_on_failure
  TCP_CHECK {
    connect_timeout 1
  }
}
</code></pre></div><h3 id="interfaces-dummy-sur-les-serveurs-postgresql">Interfaces dummy sur les serveurs PostgreSQL<a hidden class="anchor" aria-hidden="true" href="#interfaces-dummy-sur-les-serveurs-postgresql">#</a></h3>
<p>Les opérations suivantes sont à réaliser sur les serveurs PostgreSQL
seulement.</p>
<p>Pour qu&rsquo;ils soient en mesure de répondre aux clients, les serveurs PostgreSQL
doivent se considérer comme destinataires des paquets réseaux à destination des
VIP, sans générer de trafic ARP pour ces adresses. Utiliser une interface
réseau <code>dummy</code> pour placer les VIP sur les serveurs PostgreSQL est dans ce cas
la solution la plus simple.</p>
<p>Configurer le chargement du module dummy au démarrage de la machine en créant
le fichier <code>/etc/modules-load.d/dummy.conf</code> avec le contenu :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">dummy
</code></pre></div><p>Configurer les options de chargement du module dans <code>/etc/modprobe.d/z-dummy.conf</code> :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">options dummy numdummies=1
</code></pre></div><p>Charger le module :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">modprobe dummy
</code></pre></div><p>Sur RHEL/CentOS 7, créer un fichier de configuration pour l&rsquo;interface, il doit
être <em>après</em> le fichier de l&rsquo;interface principale dans l&rsquo;ordre alphabétique,
sinon la route par défaut sera placée sur l&rsquo;interface <code>dummy</code> :</p>
<p>Pour l&rsquo;IP virtuelle de l&rsquo;accès en lecture/écriture, <code>/etc/sysconfig/network-scripts/ifcfg-vip1</code> :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">DEVICE=dummy0
DEFROUTE=no
BOOTPROTO=none
IPADDR=10.0.2.10
NETMASK=255.255.255.0
ONBOOT=yes
TYPE=Ethernet
NM_CONTROLLED=no
</code></pre></div><p>Pour l&rsquo;IP virtuelle de l&rsquo;accès en lecture seule, <code>/etc/sysconfig/network-scripts/ifcfg-vip2</code> :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">DEVICE=dummy0:0
DEFROUTE=no
BOOTPROTO=none
IPADDR=10.0.2.11
NETMASK=255.255.255.0
ONBOOT=yes
TYPE=Ethernet
NM_CONTROLLED=no
</code></pre></div><p>Activer les interfaces :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">$ sudo ifup vip1
$ sudo ifup vip2
</code></pre></div><p>Sur RHEL/CentOS 8, utiliser <code>nmcli</code> :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">$ sudo nmcli connection add type dummy ifname dummy0 \
    ipv4.method manual ipv4.addresses &#34;10.0.2.10/24, 10.0.2.11/24&#34;
$ sudo nmcli connection up dummy-dummy0
</code></pre></div><p>Sur Debian/Ubuntu, dans <code>/etc/network/interfaces</code> :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">auto dummy0
iface dummy0 inet static
    address 10.0.2.10/24
    
auto dummy0:0
iface dummy0:0 inet static
    address 10.0.2.11/24
</code></pre></div><p>Activer les interfaces :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">$ sudo ifup vip1
$ sudo ifup vip2
</code></pre></div><h3 id="activation-du-service">Activation du service<a hidden class="anchor" aria-hidden="true" href="#activation-du-service">#</a></h3>
<p>Le service est géré par systemd :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">$ sudo systemctl enable --now keepalived
</code></pre></div><p>Les messages et traces de Keepalived sont écrites dans syslog et apparaissent
dans le journal.</p>
<p>Les modifications de configuration, comme un ajout ou une suppression de
<code>real_server</code> requièrent seulement un rechargement du service :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">$ sudo systemctl reload keepalived
</code></pre></div><h2 id="supervision">Supervision<a hidden class="anchor" aria-hidden="true" href="#supervision">#</a></h2>
<p>On peut configurer les instances VRRP pour que des notifications soit envoyées
sur les changements d&rsquo;état. Cela peut se faire par mail (SMTP) ou par
l&rsquo;exécution de scripts (paramètres <code>notify_master</code>, <code>notify_backup</code>,
<code>notify_fault</code>, etc)</p>
<p>Pour les blocs <code>real_server</code>, les paramètres sont <code>notify_up</code> et <code>notify_down</code>.</p>
<p>La syntaxe des paramètres de notification est :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">notify_XXX &lt;STRING&gt;|&lt;QUOTED-STRING&gt; [username [groupname]]
</code></pre></div><p>Pour examiner l&rsquo;équilibrage de charge, l&rsquo;outil <code>ipvsadm</code> est intéressant, par
exemple pour la VIP en écriture (le poids indique l&rsquo;instance primaire) :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback"># ipvsadm -l -n
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  10.0.2.10:5432 lc
  -&gt; 10.0.2.3:5432                Route   0      0          0
  -&gt; 10.0.2.4:5432                Route   50     0          0
  -&gt; 10.0.2.5:5432                Route   0      0          0
</code></pre></div><h2 id="tests">Tests<a hidden class="anchor" aria-hidden="true" href="#tests">#</a></h2>
<p>Les tests ont été réalisés avec la configuration décrite précédemment sur des
machines virtuelles KVM en CentOS 8.2, avec Keepalived v2.1.5 et PostgreSQL
13.3.</p>
<h3 id="ecritures-et-bascule">Ecritures et bascule<a hidden class="anchor" aria-hidden="true" href="#ecritures-et-bascule">#</a></h3>
<p>Préparer un utilisateur et une base de données pour les tests :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">$ export PGPASSWORD=&#34;xxxx&#34;
$ createuser -h 10.0.2.10 -U postgres -P my_user 
$ createdb -h 10.0.2.10 -U postgres my_db
$ psql -h 10.0.2.10 -U my_user -c &#34;create table t1 (i int)&#34; my_db
</code></pre></div><p>Lancer une boucle qui insère une ligne toutes les secondes :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">$ while $(true); \
    do psql -X -h 10.0.2.10 -U my_user -c &#34;insert into t1 values (1)&#34; my_db; \
    sleep 1; done
</code></pre></div><p>Voici l&rsquo;état du load balancing sur la machine keepalived qui porte l&rsquo;IP
virtuelle en écriture (on remarque le poids à 50 pour le <em>Leader</em>) :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">$ ipvsadm -l -n
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  10.0.2.10:5432 lc
  -&gt; 10.0.2.3:5432                Route   0      0          0
  -&gt; 10.0.2.4:5432                Route   0      0          0
  -&gt; 10.0.2.5:5432                Route   50     0          9
TCP  10.0.2.11:5432 lc
  -&gt; 10.0.2.3:5432                Route   50     0          0
  -&gt; 10.0.2.4:5432                Route   50     0          0
  -&gt; 10.0.2.5:5432                Route   50     0          0
</code></pre></div><p>On provoque alors une bascule coté Patroni :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">$ patronictl switchover
</code></pre></div><p>Lorsque le cluster est revenu à un état stable, <code>ipvsadm</code> montre l&rsquo;évolution des
poids, le <em>Leader</em> à changé :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">$ ipvsadm -l -n
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  10.0.2.10:5432 lc
  -&gt; 10.0.2.3:5432                Route   50     0          0
  -&gt; 10.0.2.4:5432                Route   0      0          0
  -&gt; 10.0.2.5:5432                Route   0      9          3
TCP  10.0.2.11:5432 lc
  -&gt; 10.0.2.3:5432                Route   50     0          0
  -&gt; 10.0.2.4:5432                Route   50     0          0
  -&gt; 10.0.2.5:5432                Route   50     0          0
</code></pre></div><p>Du côté de « l&rsquo;application », on a les traces suivantes, montrant la bascule,
qui a duré environ 15 secondes :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">INSERT 0 1
INSERT 0 1
INSERT 0 1
INSERT 0 1
psql: error: FATAL:  the database system is shutting down
FATAL:  the database system is shutting down
psql: error: FATAL:  the database system is shutting down
FATAL:  the database system is shutting down
psql: error: FATAL:  the database system is shutting down
FATAL:  the database system is shutting down
psql: error: could not connect to server: Connection refused
	Is the server running on host &#34;10.0.2.10&#34; and accepting
	TCP/IP connections on port 5432?
psql: error: could not connect to server: Connection refused
	Is the server running on host &#34;10.0.2.10&#34; and accepting
	TCP/IP connections on port 5432?
psql: error: could not connect to server: Connection refused
	Is the server running on host &#34;10.0.2.10&#34; and accepting
	TCP/IP connections on port 5432?
psql: error: could not connect to server: Connection refused
	Is the server running on host &#34;10.0.2.10&#34; and accepting
	TCP/IP connections on port 5432?
psql: error: could not connect to server: Connection refused
	Is the server running on host &#34;10.0.2.10&#34; and accepting
	TCP/IP connections on port 5432?
psql: error: could not connect to server: Connection refused
	Is the server running on host &#34;10.0.2.10&#34; and accepting
	TCP/IP connections on port 5432?
psql: error: could not connect to server: Connection refused
	Is the server running on host &#34;10.0.2.10&#34; and accepting
	TCP/IP connections on port 5432?
psql: error: could not connect to server: Connection refused
	Is the server running on host &#34;10.0.2.10&#34; and accepting
	TCP/IP connections on port 5432?
ERROR:  cannot execute INSERT in a read-only transaction
ERROR:  cannot execute INSERT in a read-only transaction
psql: error: could not connect to server: Connection refused
	Is the server running on host &#34;10.0.2.10&#34; and accepting
	TCP/IP connections on port 5432?
INSERT 0 1
INSERT 0 1
INSERT 0 1
INSERT 0 1
</code></pre></div><h3 id="equilibrage-de-charge">Equilibrage de charge<a hidden class="anchor" aria-hidden="true" href="#equilibrage-de-charge">#</a></h3>
<style type="text/css">.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative}</style>
<svg width="0" height="0" display="none" xmlns="http://www.w3.org/2000/svg"><symbol id="tip-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"/></symbol><symbol id="note-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="warning-notice" viewBox="0 0 576 512" preserveAspectRatio="xMidYMid meet"><path d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="info-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"/></symbol></svg><div class="notice note" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#note-notice"></use></svg></span>Remarque</p><p>La machine de test n&rsquo;étant pas assez puissante (surtout au
niveau du nombre de CPU/Core), le résultat du bench importe moins que la
répartition des connexions entre les machines.</p></div>

<p>Initialiser la base de données pour pgbench :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">$ pgbench -h 10.0.2.10 -U my_user -i my_db
</code></pre></div><p>Lancer un pgbench en lecture seule sur l&rsquo;instance primaire en lecture/écriture :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">$ pgbench -h 10.0.2.10 -U my_user -n -S -j 4 -c 75 -T 30 my_db
transaction type: &lt;builtin: select only&gt;
scaling factor: 1
query mode: simple
number of clients: 75
number of threads: 4
duration: 30 s
number of transactions actually processed: 176106
latency average = 12.843 ms
tps = 5839.685783 (including connections establishing)
tps = 5848.370529 (excluding connections establishing)
</code></pre></div><p>Durant l&rsquo;exécution, <code>ipvsadm</code> montre la répartition des connexions :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">$ ipvsadm -l -n
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  10.0.2.10:5432 lc
  -&gt; 10.0.2.3:5432                Route   50     75         1
  -&gt; 10.0.2.4:5432                Route   0      0          0
  -&gt; 10.0.2.5:5432                Route   0      0          0
TCP  10.0.2.11:5432 lc
  -&gt; 10.0.2.3:5432                Route   50     0          0
  -&gt; 10.0.2.4:5432                Route   50     0          0
  -&gt; 10.0.2.5:5432                Route   50     0          0
</code></pre></div><p>Puis sur l&rsquo;IP virtuelle en lecture seule :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">$ pgbench -h 10.0.2.11 -U my_user -n -S -j 4 -c 75 -T 30 my_db
transaction type: &lt;builtin: select only&gt;
scaling factor: 1
query mode: simple
number of clients: 75
number of threads: 4
duration: 30 s
number of transactions actually processed: 220756
latency average = 10.221 ms
tps = 7337.509985 (including connections establishing)
tps = 7343.683211 (excluding connections establishing)
</code></pre></div><p>Durant l&rsquo;exécution, <code>ipvsadm</code> montre la répartition des connexions entre les
instances PostgreSQL, prouvant l&rsquo;équilibrage de charge :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">$ ipvsadm -l -n
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  10.0.2.10:5432 lc
  -&gt; 10.0.2.3:5432                Route   50     0          0
  -&gt; 10.0.2.4:5432                Route   0      0          0
  -&gt; 10.0.2.5:5432                Route   0      0          0
TCP  10.0.2.11:5432 lc
  -&gt; 10.0.2.3:5432                Route   50     25         0
  -&gt; 10.0.2.4:5432                Route   50     25         0
  -&gt; 10.0.2.5:5432                Route   50     25         0
</code></pre></div><h2 id="fichiers-de-configuration-complets">Fichiers de configuration complets<a hidden class="anchor" aria-hidden="true" href="#fichiers-de-configuration-complets">#</a></h2>
<h3 id="load-balancer-kad1">Load balancer KAD1<a hidden class="anchor" aria-hidden="true" href="#load-balancer-kad1">#</a></h3>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">global_defs {
  router_id KAD1
  vrrp_strict
  enable_script_security
  script_user root
}

vrrp_instance PGRW {
  state MASTER
  interface eth0
  virtual_router_id 1
  priority 150
  advert_int 1
  virtual_ipaddress {
    10.0.2.10/24 dev eth0 label eth0:1
  }
}

virtual_server 10.0.2.10 5432 {
  delay_loop 1
  lvs_method DR
  lb_algo lc # least connected
  persistence_timeout 1
  protocol TCP

  delay_before_retry 1
  connect_timeout 1
  warmup 0
  
  real_server 10.0.2.3 5432 {
    weight 50
    inhibit_on_failure
    HTTP_GET {
      connect_port 8010
      url {
        path /primary
        status_code 200
      }
    }
  }

  real_server 10.0.2.4 5432 {
    weight 50
    inhibit_on_failure
    HTTP_GET {
      connect_port 8010
      url {
        path /primary
        status_code 200
      }
    }
  }

  real_server 10.0.2.5 5432 {
    weight 50
    inhibit_on_failure
    HTTP_GET {
      connect_port 8010
      url {
        path /primary
        status_code 200
      }
    }
  }
}

vrrp_instance PGRO {
  state BACKUP
  interface eth0
  virtual_router_id 2
  priority 100
  advert_int 1
  virtual_ipaddress {
    10.0.2.11/24 dev eth0 label eth0:2
  }
}

virtual_server 10.0.2.11 5432 {
  delay_loop 1
  lvs_method DR
  lb_algo lc # least connected
  persistence_timeout 1
  protocol TCP

  delay_before_retry 1
  connect_timeout 1
  warmup 0

  real_server 10.0.2.3 5432 {
    weight 50
    inhibit_on_failure
    TCP_CHECK {
      connect_timeout 1
    }
  }

  real_server 10.0.2.4 5432 {
    weight 50
    inhibit_on_failure
    TCP_CHECK {
      connect_timeout 1
    }
  }

  real_server 10.0.2.5 5432 {
    weight 50
    inhibit_on_failure
    TCP_CHECK {
      connect_timeout 1
    }
  }
}
</code></pre></div><h3 id="load-balancer-kad2">Load balancer KAD2<a hidden class="anchor" aria-hidden="true" href="#load-balancer-kad2">#</a></h3>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">global_defs {
  router_id KAD2
  vrrp_strict
  enable_script_security
  script_user root
}

vrrp_instance PGRW {
  state BACKUP
  interface eth0
  virtual_router_id 1
  priority 100
  advert_int 1
  virtual_ipaddress {
    10.0.2.10/24 dev eth0 label eth0:1
  }
}

virtual_server 10.0.2.10 5432 {
  delay_loop 1
  lvs_method DR
  lb_algo lc # least connected
  persistence_timeout 1
  protocol TCP

  delay_before_retry 1
  connect_timeout 1
  warmup 0

  real_server 10.0.2.3 5432 {
    weight 50
    inhibit_on_failure
    HTTP_GET {
      connect_port 8010
      url {
        path /primary
        status_code 200
      }
    }
  }

  real_server 10.0.2.4 5432 {
    weight 50
    inhibit_on_failure
    HTTP_GET {
      connect_port 8010
      url {
        path /primary
        status_code 200
      }
    }
  }

  real_server 10.0.2.5 5432 {
    weight 50
    inhibit_on_failure
    HTTP_GET {
      connect_port 8010
      url {
        path /primary
        status_code 200
      }
    }
  }
}

vrrp_instance PGRO {
  state MASTER
  interface eth0
  virtual_router_id 2
  priority 150
  advert_int 1
  virtual_ipaddress {
    10.0.2.11/24 dev eth0 label eth0:2
  }
}

virtual_server 10.0.2.11 5432 {
  lvs_method DR
  lb_algo lc # least connected
  persistence_timeout 1
  protocol TCP

  delay_loop 1
  delay_before_retry 1
  connect_timeout 1
  warmup 0

  real_server 10.0.2.3 5432 {
    weight 50
    inhibit_on_failure
    TCP_CHECK {
      connect_timeout 1
    }
  }

  real_server 10.0.2.4 5432 {
    weight 50
    inhibit_on_failure
    TCP_CHECK {
      connect_timeout 1
    }
  }

  real_server 10.0.2.5 5432 {
    weight 50
    inhibit_on_failure
    TCP_CHECK {
      connect_timeout 1
    }
  }
}
</code></pre></div>
</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://www.orgrim.net/tags/postgresql/">postgresql</a></li>
      <li><a href="https://www.orgrim.net/tags/ha/">ha</a></li>
      <li><a href="https://www.orgrim.net/tags/patroni/">patroni</a></li>
      <li><a href="https://www.orgrim.net/tags/keepalived/">keepalived</a></li>
    </ul>






<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Load Balancing pour Patroni avec Keepalived on twitter"
        href="https://twitter.com/intent/tweet/?text=Load%20Balancing%20pour%20Patroni%20avec%20Keepalived&amp;url=https%3a%2f%2fwww.orgrim.net%2fpost%2f2021-06-07-keepalived-load-balancing-patroni%2f&amp;hashtags=postgresql%2cha%2cpatroni%2ckeepalived">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Load Balancing pour Patroni avec Keepalived on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwww.orgrim.net%2fpost%2f2021-06-07-keepalived-load-balancing-patroni%2f&amp;title=Load%20Balancing%20pour%20Patroni%20avec%20Keepalived&amp;summary=Load%20Balancing%20pour%20Patroni%20avec%20Keepalived&amp;source=https%3a%2f%2fwww.orgrim.net%2fpost%2f2021-06-07-keepalived-load-balancing-patroni%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Load Balancing pour Patroni avec Keepalived on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fwww.orgrim.net%2fpost%2f2021-06-07-keepalived-load-balancing-patroni%2f&title=Load%20Balancing%20pour%20Patroni%20avec%20Keepalived">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Load Balancing pour Patroni avec Keepalived on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.orgrim.net%2fpost%2f2021-06-07-keepalived-load-balancing-patroni%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Load Balancing pour Patroni avec Keepalived on whatsapp"
        href="https://api.whatsapp.com/send?text=Load%20Balancing%20pour%20Patroni%20avec%20Keepalived%20-%20https%3a%2f%2fwww.orgrim.net%2fpost%2f2021-06-07-keepalived-load-balancing-patroni%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Load Balancing pour Patroni avec Keepalived on telegram"
        href="https://telegram.me/share/url?text=Load%20Balancing%20pour%20Patroni%20avec%20Keepalived&amp;url=https%3a%2f%2fwww.orgrim.net%2fpost%2f2021-06-07-keepalived-load-balancing-patroni%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main><footer class="footer">
    <span>&copy; 2021 <a href="https://www.orgrim.net/">code. grind. sleep.</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>



<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

</body>

</html>
